#include "AlpsLicense.h"

#ifndef AlpsAllPara_h
#define AlpsAllPara_h

#include "AlpsKnowledge.h"
#include "AlpsParameters.h"

//#############################################################################

//class AlpsEncoded;

//** Parameters used in Alps. */
class AlpsAllParam : public AlpsParameterSet {
 public:
  /** Character parameters. All of these variable are used as booleans
      (ture = 1, false = 0). */
  enum chrParams{
    // The dummy is needed so the allocation won't try for 0 entries.
    /** Input date from file or not. */
    inputFromFile,
    ///
    endOfChrParams
  };

  /** Integer paramters. */
  enum intParams{
    /** The total number of processes that are used. */
    processNum,
    /** The number of worker processes that are used. */
    workerProcessNum,
    /** The number of nodes initially generated by the master. */
    initialNodeNum,
    /** The size of memory allocated for AlpsEnocoded::type_ in message buf. */
    typeSize,
    /** The size/number of nodes of a unit work. */
    unitWorkNodes,
    /** The max num of solution can be stored in a solution pool. */
    maxNumSolustion,
    /** The size of memory allocated for small size message. */
    smallSize, 
    /** The size of memory allocated for medium size message. */
    mediumSize,
    /** The size of memory allocated for large size message. */
    largeSize,
    /** The size of extra memory allocated for a buffer. */
    bufSpare,
    /** If the num of nodes in the node pool of a worker is no more than
	this threshold, this worker will not share work with others. */
    minNodeNum,
    ///
    endOfIntParams
  };

  /** Double parameters. */
  enum dblParams{
    /** The time length of a unit work. */
    unitWorkTime, 
    /** The time period of doing loading balance/termination check. */
    balancePeriod,
    /** The exponent of the formula to calculate workload. */
    rho,
    /** If less than this number, it is considered zero workload. */
    zeroLoad,
    /** It is between 1.0 - infty. When the workload in process is more than 
	the average workload timing donorThreshold, it is a donor in load 
	balancing. */
    donorThreshold,
    /** It is between 0.0 - 1.0. When the workload in process is less than 
	the average workload timing receiverThreshold, it is a receiver. */
    receiverThreshold,
    ///
    endOfDblParams
  };

  /** String parameters. */
  enum strParams{
    dataFile,
    ///
    endOfStrParams
  };

  /** There are no string array parameters. */
  enum strArrayParams{
    strArrayDummy,
    ///
    endOfStrArrayParams
  };

  /**@name Constructors. */
  /*@{*/
  /** The default constructor creates a parameter set with from the template
      argument structure. The keyword list is created and the defaults are
      set. */
  AlpsAllParam() :
    AlpsParameterSet(
    static_cast<int>(endOfChrParams),
    static_cast<int>(endOfIntParams),
    static_cast<int>(endOfDblParams),
    static_cast<int>(endOfStrParams),
    static_cast<int>(endOfStrArrayParams)
    )
    {
      createKeywordList();
      setDefaultEntries();
    }
  /*@}*/
  

 public:
    AlpsAllParam& operator=(const AlpsAllParam& x) {
      // no need to delete anything, since the size of (almost) everything is
      // the same, just copy over
      // -- The static_cast is needed to satisfy the more picky IBM Visual Age
      //    C++ compiler
      std::copy(x.cpar, x.cpar + static_cast<int>(endOfChrParams),
		cpar);
      std::copy(x.ipar, x.ipar + static_cast<int>(endOfIntParams),
		ipar);
      std::copy(x.dpar, x.dpar + static_cast<int>(endOfDblParams),
		dpar);
      std::copy(x.spar, x.spar + static_cast<int>(endOfStrParams),
		spar);
      std::copy(x.sapar,
		x.sapar + static_cast<int>(endOfStrArrayParams),
		sapar);
      return *this;
    }

  /**@name Query methods 
      
     The members of the parameter set can be queried for using the overloaded
     entry() method. Using the example in the class
     documentation the user can get a parameter with the
     "<code>param.entry(USER_par::parameter_name)</code>" expression.
  */
  /*@{*/
  ///
  inline char
    entry(const chrParams key) const { return cpar[key]; }
  ///
  inline int
    entry(const intParams key) const { return ipar[key]; }
  ///
  inline double
    entry(const dblParams key) const { return dpar[key]; }
  ///
  inline const AlpsString&
    entry(const strParams key) const { return spar[key]; }
  ///
  inline const AlpsVec<AlpsString>&
    entry(const strArrayParams key) const { return sapar[key]; }
  /*@}*/

  //---------------------------------------------------------------------------
  /// char* is true(1) or false(0), not used
  void setEntry(const chrParams key, const char * val) {
    cpar[key] = atoi(val); }
  /// char is true(1) or false(0), not used
  void setEntry(const chrParams key, const char val) {
    cpar[key] = val; }
  /// This method is the one that ever been used.
  void setEntry(const chrParams key, const bool val) {
    cpar[key] = val; }
  ///
  void setEntry(const intParams key, const char * val) {
    ipar[key] = atoi(val); }
  ///
  void setEntry(const intParams key, const int val) {
    ipar[key] = val; }
  ///
  void setEntry(const dblParams key, const char * val) {
    dpar[key] = atof(val); }
  ///
  void setEntry(const dblParams key, const double val) {
    dpar[key] = val; }
  ///
  void setEntry(const strParams key, const char * val) {
    spar[key] = val; }
  ///
  void setEntry(const strArrayParams key, const char *val) {
    sapar[key].push_back(val); }

  //---------------------------------------------------------------------------

  /**@name Packing/unpacking methods */
  /*@{*/
  /** Pack the parameter set into the buffer. */
  void pack(AlpsEncoded& buf) {
    buf.pack(cpar, endOfChrParams)
      .pack(ipar, endOfIntParams)
      .pack(dpar, endOfDblParams);
    for (int i = 0; i < endOfStrParams; ++i)
      buf.pack(spar[i]);
    for (int i = 0; i < endOfStrArrayParams; ++i) {
      buf.pack(sapar[i].size());
      for (size_t j = 0; j < sapar[i].size(); ++j)
	buf.pack(sapar[i][j]);
    }
  }
  /** Unpack the parameter set from the buffer. */
  void unpack(AlpsEncoded& buf) {
    int dummy;
    // No need to allocate the arrays, they are of fixed length
    dummy = static_cast<int>(endOfChrParams);
    buf.unpack(cpar, dummy, false);
    dummy = static_cast<int>(endOfIntParams);
    buf.unpack(ipar, dummy, false);
    dummy = static_cast<int>(endOfDblParams);
    buf.unpack(dpar, dummy, false);
    for (int i = 0; i < endOfStrParams; ++i)
      buf.unpack(spar[i]);
    for (int i = 0; i < endOfStrArrayParams; ++i) {
      size_t str_size;
      buf.unpack(str_size);
      sapar[i].reserve(str_size);
      for (size_t j = 0; j < str_size; ++j){
	sapar[i].unchecked_push_back(AlpsString());
	buf.unpack(sapar[i].back());
      }
    }
  }
  /*@}*/

  /** Method for creating the list of keyword looked for in the parameter
      file. */
  virtual void createKeywordList();
  /** Method for setting the default values for the parameters. */
  virtual void setDefaultEntries();
  /*@}*/


};

#endif
